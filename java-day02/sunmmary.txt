클래스(객체)안에 작성한 함수 = 메소드(method)

변수
    자바에서는 변수의 크기를 지정하고 생성
    변수의 크기 = 데이터 타입(자료형)
        변수의 선언
            타입 식별자 = 초기값;

        자료형 - 기본 자료형, 참조 자료형(String)

데이터의 크기
byte < short < int < long < float <double < String

정수 < 실수 < 문자열

변수는 변경되지 않지만, 데이터의 타입은 변경될 수 있다

형변환(Type Casting)
데이터의 타입이 변하는 것
변수의 값을 꺼내서(복사) 새로운 자료형으로 변환
규칙
1. 작은 자료형의 데이터를 큰 자료형의 데이터로 변환할 때
    자동으로 처리 - 자동 형변환, 암시/묵시적 형 변환
2. 큰 자료형의 데이터를 작은 자료형의 데이터로 변환할 때
    강제적으로 처리 - 강제 형변환, 명시적 형변환
        형변환 연산자(Casting Operator)
        - '('와 ')' 사이에 변환시킬 자료형을 작성하고 값(변수)앞에 붙임
        ex. (float)3; -> 3.0으로 변환

        주로 숫자 데이터들 간에 형변환을 진행하는 경우가 많음

        숫자를 문자열로 변환하거나 숫자 문자열을 숫자로 변환하는 경우도 있음
        - 숫자 -> 문자열, 숫자문자열 -> 숫자
        이 경우, 변환을 위한 제공되는 메소드를 사용

        숫자 -> 문자열 변환에 사용할 수 있는 간단한 연산자
        + : 결합 연산자
        숫자 + "(문자가 들어가는 공백)" -> 문자열로 변환, 위치는 상관없음 "(문자가 들어가는 공백)" + 숫자
        자동 형변환을 응용하는 방법

자바의 기초 문법
    1. 자바 프로그램은 class 단위로 작성한다
        최소 하나의 파일은 하나의 class 로 구성, 여러 class 로 하나의 파일을 작성할 수 있음, 한개의 파일로 구성이 될 수도 있고
        하나의 class 는 여러 파일로 작성을 할 수 없음
    2. 명령은 문장 (Statement) 단위로 실행되며, 문자의 끝은 ';'이어야 한다
        ';' 생략 불가
    3. 여러 문장을 묶어준 것을 block(블록)이라고 하며, 블록의 시작은 '{', 끌은 '}'로 표시한다
    4. 블록의 끝에는 ';'을 붙이지 않는다 (예외 있음)

식별자 명령 규칙 (Naming convention)
식별자 - 클래스명, 메소드명, 변수명 등
강제 규칙
    1. 대소문자를 구분하며 길이에 제한은 없다
    2. 예약어를 사용할 수 없다
        ex. int, float 같은 타입의 키워드,
            또는 if 와 else같은 제어문
    3. 숫자로 시작할 수 없다
        ex. test01(가능), 1test(불가), t1est(가능)
    4. 특수문자는 '_', '$'만 사용 가능
        - $harp(가능), S#arp(불가), _test(가능)
권장 규칙
    1. 클래스명은 첫글자를 대문자로 하자 (pascal case)
    2. 메소드명, 변수명의 첫글자는 소문자로 하자 (camel case)
    3. 여러 단어로 이름을 작성한 경우 camel case 로 작성하자
    4. 상수는 모든 글자를 대문자로 작성하자 (snake case)
        단어 구분은 '_'(언더바)로 구분
        ex. MAX_NUMBER

변수, 상수, 리터럴
변수는 값을 변경할 수 있지만, 상수는 초기값을 변경할 수 없다
    - 상수 선언시 초기화를 반드시 해야한다
리터럴은 값 자체를 말한다 (들어가는 값)
상수 선언 방법.
    final int MAX = 100; (지금 들어가는 데이터가 마지막이다)
        (final 은 제어자)

        선언 형식
        ex. 앞에 클래스가 들어가면 클래스 - 접근 제어자 class 클래스명 [option] {...}
                               메소드 - 접근 제어자 기타 제어자 타입 메소드명(파라미터 목록) {...}
            (기타 제어자 : final, static, abstract)
                               변수 - 접근 제어자 타입 변수명; = 접근제어자는 들어갈 수도 안 들어 갈 수도있음
                               상수는 접근 제어자 뒤에 기타 제어자가 들어감

    타입의 기본 값 - 비트 값이 0인 값 들. (숫자가 아닌 기억 공간(메모리)의 값)0
    boolean - false(는 0이다, 비운상태) / true(는 0이 아니다)
    clear - '\u0000'
    정수형(byte, short, int, long) - 0(0L)
    실수형
    float - 0.0(0.0f)
    double - 0.0(0.0d) - 거의 안 씀, d를 안넣어도 됨
    String 포함 참조형 - null

    많이하는 실수 - String = ""; <- 기본 값으로 선언한 것이 아님
        null과 "(공백 문자열)"은 다르다.

출력 명령문
    System.out.println(); - 문장 출력 후 줄 바꿈
    System.out.print(); - 문장 출력 후 줄을 바꾸지 않음
    글자 사이 . 은 클래스나 메소드
    라이브러리 : 내가 만들지 않은 클래스의 묶음
    완성된 프로그램 = 라이브러리 + 내가 작성한 코드

    (클래스) 라이브러리는 패키지 단위로 저장

    클래스를 가져다 쓴다 가정하면 경로를 전부 작성해야함
    클래스명은 대문자 패키지명은 소문자

    import 키워드 : 라이브러리를 포함시키는 명령어
        import 패키지.클래스명;


        클래스의 구분
            1. 정보 클래스 : 단순히 데이터를 묶어서 처리하기 위한 목적의 클래스
                           (주로 변수들로만 이루어짐, 정보를 모아서 묶음으로 만들어 클래스를 만듦)
            2. 부품 클래스 : 전체 프로그램의 일부 기능만을 처리하기 위한 목적의 클래스
                           정보 부품 만으로는 단독으로 프로그램을 만들기는 어려움
            3. 제어 클래스 : 정보 클래스와 부품 클래스를 사용하는 클래스
                            정보 부품을 사용함

            하나의 객체로 하나의 프로그램
            코드는 너무 길어지면 나중에 유지보수가 어려움이 생기고 생산성이 떨어짐
            클래스를 구분을 한다면 정보 부품 제어

Scanner 클래스 : 입력 객체를 생성하기 위한 클래스
    각 타입에 맞는 값을 입력 받기 위한 메소드가 따로 존재
        1. 정수형 : nextInt(), nextShort(), nextLong()
        2. 실수형 : nextFloat(), nextDouble()
        3. 문자열 : nextLine()

        Scanner 문제
        숫자형 데이터 입력 후 문자열 입력하면 문자열 입력을 스킵
        int a = scan.nextInt();
        String str = scan.nextLine(); - 이 문장이 정상적으로 실행되지 않음

연습 문제
    회원 가입 화면 만들기
        1. 아이디, 비밀번호, 이름, 나이, 연락처, 주소 등 입력
        2. 마지막 값 입력 후 전체내용 출력

인스턴스 참조 변수
    클래스로 생성(new)하는 인스턴스를 저장하는 변수
    클래스는 개발자정의형 타입이다
    Scanner 클래스로 만든 scan 은 인스턴스 참조 변수 - 변수, 참조형 변수
    참조형 변수는 instance 인스턴스를 저장
    String 도 클래스

숫자를 문자열로, 문자열을 숫자로 작업하는 경우가 많음
    ex. 모든 입력을 문자열로 하자
        입력 값이 숫자문자열 이라면 숫자로 변환하여 사용

    1. 숫자 -> 문자열
        String 클래스에 변환용 메소드를 활용 valueOf(숫자)
        ex. int a = 100;
        String s = String.valueOf(a);
        String s = "" + a / a + "";
    2. 숫자문자열 -> 숫자
        각 숫자형 타입에 해당하는 클래스가 있으며, 각 클래스의 변환 메소드를 활용
        Wrapper 클래스 : 기본 자료형에 객체화를 위한 클래스
            각 기본형 타입의 첫 글자를 대문자로 하는 클래스
            int -> Integer 클래스

        형변환 메소드 : parseXXX
            ex. 정수로 변환하는 메소드 : Integer.parseInt("숫자문자열");
                실수로 변환하는 메소드 : Float.parseFloat("실수문자열");

        형변환이 제외되는 메소드 : boolean 타입은 제외.

!참고 Scanner의 문제 해결 방법 2
    1. 모든 입력을 문자열로 받는다. 숫자일 경우 변환하여 사용
    2. nextLine()만 사용하여 입력을 받는다. Wrapper 클래스를 사용하여 숫자로 변환한다.

! System.out.println 이나 Scanner 는 웹 프로그래밍에서는 사용하지 않는다 !

print 메소드
    1. println() - 출력 후 줄을 바꾸는 메소드
    2. print() - 출력 후 줄을 바꾸지 않는 메소드
    3. printf() - 출력 형식을 지정하는 메소드
        System.out.printf("%d * %d = %d", a, b, c);
        a = 10, b = 2, c = 20
        화면 출력 : 10 * 2 = 20
        지시자 (%문자)
        정수 출력 할 때는 : %d
        실수 출력 할 때는 : %f
        문자열 출력 할 때는 : %s
        줄 바꿈 : %n, \n

프로그래밍 공부하는 순서
변수 > 연산자

연산자(Operator)
    프로그램의 명령어는 변수와 연산자로 구성된다
    1. 산술 연산자 : +, -, *, /, %
        ㄴ ex. 5 / 2 = 2.5 <- 자바스크립트
               5 / 2 = 2 <- 자바
           정수 연산의 결과는 무조건 정수가 나옴 (몫만 구함 / 소수점은 구하지 않음)
           연산의 결과로 형변환이 발생하지는 않는다
    2. 대입 연산자 : =, +=, -=, *=, /=, %=
        ㄴ ex. a +=2; -> a = a + 2;
    3. 증감 연산자 : ++, -- (자바스크립트와 동일)
        ㄴ ex. a++; -> a = a + 1; -> a += 1;
    4. 비교 연산자 : ==, !=, >, >=, <, <= (자바스크립트와 동일)
        ㄴ ===, !== 는 없음
          결과는 boolean 타입으로 나옴 (true/false)
          문자열 비교는 단순 비교 할 수 없음
          문자열은 String 클래스에 s1.equals(s2) 메소드로 비교
          .equals() 는 데이터 값만 비교
    5. 논리 연산자 : &&(AND), ||(OR), !(Not), ^(XOR. 배타적 논리합)
        ㄴ (자바스크립트와 동일)
            비교연산자로 작성된 연산식을 결합할 때 사용
            &&(논리곱) : 두 연산식이 모두 true 면, 전체 연산식이 true
            ||(논리합) : 두 연산식 중 하나면 true, 전체 연산식이 true
            !(NOT, 부정) : true 면 false 로, false 면 true 로
    6. 조건 연산자 : (조건식) ? A(실행할 문장) : B (실행할 문장); - 자바스크립트와 동일
        ㄴ 조건식이 true 면 A 를 실행, false 면 B 를 실행.
           논리 연산의 경우 특수한 상황에 따라 문제가 발생할 수 있음.
           &&의 경우 첫번째 조건식이 false 인 경우, 두번째 조건식을 수행하지 않는다.
           반대로 ||(or)의 경우 첫번째 조건식이 true 일때 두번째 조건식에
           추가적인 연산식이 있을 경우 수행되지 않기 때문에 결과에 영향을 줄 수 있다.
           !논리 연산의 조건식에 추가적인 연산식을 넣는 것은 바람직하지 않다.
    7. 비트 연산자 : bit 단위로 연산을 수행. (웹 분야와는 관련성이 떨어짐)
        ㄴ &, |
          하드웨어 스위치 제어(led 전광판 제어 분야)
          led 전광판에 많이 쓰임. 하드웨어를 제어할 때 쓰임 - 개발자는 사용하지 않음
          ex. 0 0 0 0 : 스위치가 모두 꺼진 상태에서 1, 3번에 신호를 준다
              1 0 1 0 의 값을  '|(or)' 연산
           -> 1 0 1 0 : 1번 3번 스위치가 on 상황에 2, 3번에 신호를 준다
              0 1 1 0 의 값을 '|(or)' 연산
           -> 1 1 0 1 : 2번 on, 3번 off
              비트는 자리가 변하지 않음(ex. 9 + 1 = 10 처럼 2자리 수로 넘어가지 않음)
              같은 자리끼리만 더함.

        shift 연산 : <<, >>
            ㄴ ex. << : 비트 값을 지정된 숫자만큼 왼쪽으로 이동.
             2진수 일 때 0 0 0 1 -> << 2 결과 : 0 1 0 0
            10진수 일 떄 8 4 2 1 << 2 결과 : 원래 1인 값이 4가 됨 - 원래 값 * 2^2(2의 2승을 곱함)
                               >> 는 나누기 / << 는 곱하기
